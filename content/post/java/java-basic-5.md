---
title: "객체 지향 프로그래밍 I"
date: 2022-06-06T00:45:00+09:00
tags: ['java']
draft: false
---

객체 지향 프로그래밍 I
<!--more-->

#
### 객체지향언어의 특징
1. 코드의 재사용성이 높다.

2. 코드의 관리가 용이하다.

3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

*너무 객체지향개념에 얽매여서 고민하기 보다는 일단 프로그램을 기능적으로 완성한 다음 어떻게 하면 보다 객체지향적으로 코드를 개선할 수 있을지를 고민하여 점차 개선해 나가는 것이 좋다.

#
### 클래스와 객체
클래스의 정의: 클래스란 객체를 정의해 놓은 것  
클래스의 용도: 클래스는 객체를 생성하는데 사용

객체의 정의: 실제로 존재하는 것, 사물 또는 개념   
객체의 용도: 객체가 가지고 있는 기능과 속성에 따라 다름

유형의 객체: 책상, 의자, 자동차, TV와 같은 사물   
무형의 객체: 수학공식, 프로그램 에러와 같은 논리나 개념   
ex.  TV설계도(클래스)는 TV라는 제품(객체)을 정의한 것이며 TV(객체)를 만드는데 사용된다.

클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다.

#
### 객체의 구성요소
클래스란 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어 있다.

속성(property) - 멤버변수(variable)   
기능(function) - 메서드(method)   
ex. 속성: 크기, 길이, 높이, 색상, 볼륨, 채널 등, 기능: 켜기, 끄기, 볼륨 높이기 낮추기, 채널 변경하기 등

#
### 객체와 인스턴스
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 한다.   
어떤 클래스로부터 만들어지는 객체를 그 클래스의 인스턴스라고 한다.

```java
클래스명 변수명;         // 클래스의 객체를 참조하기 위한 참조변수 선언
변수명 - new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
```

```java
TV = tv;             // TV클래스 타입의 참조변수 tv를 선언
tv = new TV();       // TV인스턴스를 생성한 후 생성된 TV인스턴스의 주소를 tv에 저장
```
인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.

#
### 데이터 저장형태 발전과정
1. 변수: 하나의 데이터를 저장할 수 있는 공간
2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스: 데이터와 함수의 결합(구조체 + 함수)

#
### 변수의 종류

| 변수의 종류                     | 선언위치                               | 생성시기             |
|----------------------------|------------------------------------|------------------|
| 클래스 변수 (class variable)    | 클래스 영역                             | 클래스가 메모리에 올라갈 때  |
| 인스턴스 변수(instance variable) | 클래스 영역                             | 인스턴스가 생성되었을 때    |
| 지역 변수(local variable)      | 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블록 내부) | 	변수 선언문이 수행되었을 때 |

```java
class variables {   // 클래스영역
int iv;         // 인스턴스변수
static int cv;  // 클래스변수(static변수, 공유변수)

    void mehtod {   // 매서드영역
    	int lv = 0; // 지역변수
    }
}
```

인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다.


#
### 메서드란?
특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것

```java
반환타입 메서드이름 (타입 변수명, 타입 변수명, ...) { // 선언부
// 메서드 호출 시 수행될 코드
}                                          // 구현부
```

```java
int add(int a, int b) {  // 선언부
    int result = a + b;
    return result;      // 호출한 메서드로 결과를 반환한다.
}                       // 구현부
```

#
### 메서드의 선언, 구현

선언  

매개변수 선언: 일반적인 변수 선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다.

반환타입(return type): 반환값이 없는 경우 반환타입을 void로 적어야 한다.

<br/> 

구현

return문: void가 아닌 경우 반환값이 반드시 표현되어 있어야 한다. 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.

지역변수: 메서드 내에 선언된 변수

#
### 메서드의 호출
인수와 매개변수  

메서드를 호출 할 때 괄호 안에 지정해준 값들을 인수 또는 인자라고 하는데, 개수와 순서는 메서드에 선언된 매개변수와 일치해야 한다.

인자의 타입은 매개변수의 탕비과 일치하거나 자동 형변환이 가능한 것이어야 한다.


*메서드에 선언된 매개변수의 개수보다 많은 값을 괄호에 넣거나 다른 값을 넣으면 컴파일러가 에러를 발생시킨다.

반환타입이 void가 아닌 경우 메서드가 작업을 수행하고 반환한 값을 대입연산자로 변수에 저장하는 것이 보통이지만, 저장하지 않아도 문제가 되지 않는다.

#
###
호출스택
- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.

- 메서드가 수행을 마치고 나면 사용했던 메모리를 반환하고 스택에서 제거된다.

- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.

- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

#
### 기본형 매개변수
기본형 매개변수: 변수의 값을 읽기만 할 수 있다. (read only)   
참조형 매개변수: 변수의 값을 읽고 변경할 수 있다. (read & write)

#
### static을 언제 붙여야 할까?
1. 클래스를 설계할 때 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.

2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.

3. 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.

4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

#
### 메서드 간의 호출과 참조
같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.

클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에만 인스턴스를 생성해야 한다. 
이유는 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.

#
### 오버로딩 (overloading)
1. 메서드 이름이 같아야 한다.

2. 매개변수의 개수 또는 타입이 달라야 한다.

3. 반환 타입은 관계없다.

*오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.


#
### 생성자 (constructor)
1. 생성자의 이름은 클래스의 이름과 같아야 한다.

2. 생성자는 리턴 값이 없다.

```java
클래스이름(타입 변수명, 타입 변수명, ...) {
    // 인스턴스 생성 시 수행될 코드
    // 주로 인스턴스 변수의 초기화 코드를 적는다.
}
```
연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.

클래스에 성상자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 기본 생성자 덕분이다.

컴파일 할 때, 소스파일의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일 한다. 특별히 인스턴스 초기화 작업이 요구되어지지 않는다면 생성자를 정의하지 않고 컴파일러가 제공하는 기본 생성자를 사용하는 것도 좋다.

*단 컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 클래스 내에 생성자가 하나도 없을 때 뿐이라는 것을 명심해야 한다.

```java
클래스 이름 () { // 기본 생성자

}
```

#
### 매개변수가 있는 생성자
인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.
```
1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?
```


#
### 생성자에서 다른 생성자 호출하기 - this()
```
- 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
```

#
### 객체 자신을 가리키는 참조변수 - this
```
this: 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어 있다.
모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
this(), this(매개변수): 생성자. 같은 클래스의 다른 생성자를 호출할 때 사용한다.
```

#
### 변수의 초기화
```
멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택이지만, 지역변수의 초기화는 필수이다.
```

#
### 멤버변수의 초기화
```
1. 클래스 변수(cv) 초기화 → 인스턴스(iv) 초기화
2. 자동 초기화 → 명시적 초기화(간단) → 초기화 블럭, 생성자(복잡)
```

명시적 초기화(explict initialization)

변수를 선언과 동시에 초기화 하는 것. 가장 기본적이면서도 간단한 초기화 방법이므로 가장 우선적으로 고려되어야 한다.
보다 복잡한 초기화 작업이 필요할 때는 초기화 블럭 또는 생성자를 사용해야 한다.


초기화 블럭(initialization block)
```
클래스 초기화 블럭: 클래스 변수의 복잡한 초기화에 사용된다.  
인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용된다. 
``` 
인스턴스 초기화 블럭은 단순히 클래스 내에 블럭{ }을 만들고 그 안에 코드를 작성하기만 하면 된다.  
클래스 초기화 블럭은 인스턴스 초기화 블럭 앞에 단순히 static을 덧붙이기만 하면 된다.